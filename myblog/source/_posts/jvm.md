---
title: jvm
tags: jvm
categories: java基础
abbrlink: f0675471
date: 2021-05-10 21:35:16
---

#### jvm（hotSpot）的体系结构

![jvm体系结构.png](https://i.loli.net/2021/05/10/pZ1nxflVTFqdOaC.png)

#### 类加载器

##### 类加载器的种类

- 启动类根加载器                      lib/rb.jar
- 扩展类加载器                          lib/exc/*.jar
- 应用程序加载器                     classpath

##### 类加载器概念

我们编写号类文件之后，通过类加载器class loader加载成class文件，class文件也可通过getClassload转换到class loader里，如果我们需要实例化，则一般常用new的方式实例化成具体的对象，对象也可通过getClass得到想要的class文件。其中class是抽象的，对象是具体的实现。每个对象都是一个实例化。

#### 双亲委派机制

##### 优点：

双亲委派模型是为了保证Java核心库的类型安全。所有Java应用都至少需要引用java.lang.Object类，在运行时这个类需要被加载到Java虚拟机中。如果该加载过程由自定义类加载器来完成，可能就会存在多个版本的java.lang.Object类，而且这些类之间是不兼容的。

通过双亲委派模型，对于Java核心库的类的加载工作由启动类加载器来统一完成，保证了Java应用所使用的都是同一个版本的Java核心库的类，是互相兼容的。

##### 流程：

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。三种加载器的子父关系：启动类根加载器/扩展类加载器 /应用程序加载器      

#### native关键字

- 凡是用native修饰的方法，说明java程序的作用范围达不到，需要调用底层的C语言
- 会进入本地方法栈调用本地方法接口JNI
- JNI的作用是扩展java的应用，融合不同的语言为java使用
- 存储native方法的区域叫做native Method Stack即本地方法栈
- 在最终执行的时候会加载到本地方法库通过JNI进行调用

#### PC寄存器

- 它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域
- 在jvm规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致
- 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的java方法的JVM指令地址；或者，如果在执行native方法，则是未指定值（undefined）,因为程序计数器不负责本地方法栈。
- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成
- 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
- 它是唯一一个在java虚拟机规范中没有规定任何OOM（Out Of Memery）情况的区域,而且没有垃圾回收

#### 方法区、元空间

- 方法区（Method Area）与 Java 堆一样，是所有线程共享的内存区域。
- JDK7 之前（永久代）用于存储已被虚拟机加载的类信息、常量、字符串常量、类静态变量、即时编译器编译后的代码等。即static、final、Class、常量池。
- JDK8 彻底将永久代移除出 HotSpot JVM，将其原有的数据迁移至 Java Heap 或 Native Heap，取代它的是另一个内存区域被称为元空间(Metaspace）

元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。

#### 栈stack

- 栈内存主管程序的运行和线程同步
- 线程结束，栈内存也就释放不存在垃圾回收机制
- 栈存储的有8大基本数据类型+对象引用+实例方法
- 栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活。
- 如果栈满则会抛出stackOverFlowError错误

#### 堆heap

- 一个jvm只有一个堆内存，堆内存的大小是可以调节的。

- 类加载器读取类文件之后，会把类、方法、常亮放入堆中，保存我们引用类型的真实对象
- 堆分为：新生区（伊甸园区eden、from、to）、老年区

~~~java
-Xms1024m -Xmx1024m -XX:+PrintGCDetails			//自定义堆的内存空间为1024m，其中xms时初始化内存大小，xmx时最大分配内存·
 //新生代总内存   305664K,
PSYoungGen      total 305664K, used 47186K [0x00000000eab00000, 0x0000000100000000, 0x0000000100000000)  
   //伊甸园区 使用率                               
  eden space 262144K, 18% used [0x00000000eab00000,0x00000000ed914aa0,0x00000000fab00000)
  //幸村一区、幸存0区的内次使用率                             
  from space 43520K, 0% used [0x00000000fd580000,0x00000000fd580000,0x0000000100000000)
  to   space 43520K, 0% used [0x00000000fab00000,0x00000000fab00000,0x00000000fd580000)
  //养老区的内存总数                            
 ParOldGen       total 699392K, used 0K [0x00000000c0000000, 0x00000000eab00000, 0x00000000eab00000)
  //养老区内存使用率                                       
  object space 699392K, 0% used [0x00000000c0000000,0x00000000c0000000,0x00000000eab00000)
  //元空间的 的逻辑内存，实际上存储在本地内存中                             
 Metaspace       used 3396K, capacity 4500K, committed 4864K, reserved 1056768K
  class space    used 369K, capacity 388K, committed 512K, reserved 1048576K
                                 
  -Xms16m -Xmx16m -XX:+PrintGCDetails      //自定义空间为16m，可以看出明显的差别                       
  PSYoungGen      total 4608K, used 851K [0x00000000ffb00000, 0x0000000100000000, 0x0000000100000000)
  eden space 4096K, 8% used [0x00000000ffb00000,0x00000000ffb586f0,0x00000000fff00000)
  from space 512K, 97% used [0x00000000fff00000,0x00000000fff7c7a0,0x00000000fff80000)
  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)
 ParOldGen       total 11264K, used 786K [0x00000000ff000000, 0x00000000ffb00000, 0x00000000ffb00000)
  object space 11264K, 6% used [0x00000000ff000000,0x00000000ff0c4a28,0x00000000ffb00000)
 Metaspace       used 3447K, capacity 4500K, committed 4864K, reserved 1056768K
  class space    used 370K, capacity 388K, committed 512K, reserved 1048576K 
                                
                                
//当运行的对象过多时会进行轻量级的GC清理和重量级的GC清理，如果重量级的GC清理也不成功，则会提示 java.lang.OutOfMemoryError: Java heap space内存溢出
[GC (Allocation Failure) --[PSYoungGen: 3072K->3072K(3584K)] 14077K->14333K(14848K), 0.0025489 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]                                 
[Full GC (Ergonomics) [PSYoungGen: 3072K->3071K(3584K)] [ParOldGen: 11208K->11208K(11264K)] 14280K->14279K(14848K), [Metaspace: 36735K->36735K(1083392K)], 0.0202492 secs] [Times: user=0.01 sys=0.00, real=0.02 secs] 
2021-05-11 21:38:46.349 ERROR 8084 --- [  restartedMain] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} init error

java.lang.OutOfMemoryError: Java heap space
~~~

#### 垃圾回收GC

**1、分代收集算法：** 堆中的每个对象都会添加一个引用计数器。每当一个地方引用这个对象时，计数器值 `+1`；当引用失效时，计数器值 `-1`。任何时刻计数值为 `0` 的对象就是不可能再被使用的。这种算法无法解决**对象之间相互引用的情况**。

**2、复制算法：**将可用内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉。这种算法适用于对象存活率低的场景，比如新生代。

**3、标记、清除、压缩算法：**首先垃圾回收器此时会找出哪些内存在使用中，那些未使用，接着删除未使用对象并内存分配器会保留指向可用内存的引用，以供分配新对象，最后为了提升性能，删除了未引用对象后，还可以将剩下的已引用对象放在一起（压缩），这样就能更简单快捷地分配新对象了。一般可以设置N次标记清除之后，压缩一次。其中N最多15次。

**4、分代收集算法：**

- 新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的。新生代内存按照 8:1:1 的比例分为一个eden区和两个survivor(survivor0，survivor1)区，大部分对象在Eden区中生成。在进行垃圾回收时，先将eden区存活对象复制到survivor0区，然后清空eden区，当这个survivor0区也满了时，则将eden区和survivor0区存活对象复制到survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后交换survivor0区和survivor1区的角色（即下次垃圾回收时会扫描Eden区和survivor1区），即保持survivor0区为空，如此往复。特别地，当survivor1区也不足以存放eden区和survivor0区的存活对象时，就将存活对象直接存放到老年代。如果老年代也满了，就会触发一次FullGC，也就是新生代、老年代都进行回收。注意，新生代发生的GC也叫做MinorGC，MinorGC发生频率比较高，不一定等 Eden区满了才触发。
- 老年代存放的都是一些生命周期较长的对象，就像上面所叙述的那样，在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。此外，老年代的内存也比新生代大很多(大概比例是1:2)，当老年代满时会触发Major GC(Full GC)，老年代对象存活时间比较长，因此FullGC发生的频率比较低。
  

